<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>The Git Parable – Telegraph</title>
    <style>
      body {
        background-color: #1f1f1f;
        color: #fff;
        font-family: Arial, sans-serif;
        max-width: 800px; /* Добавлено правило для ограничения ширины контейнера */
        margin: 0 auto;  /* Центрирование контейнера */
      }
      h1 {
        color: #ffa500;
      }
      a {
        color: #00ff00; /* Зелёный цвет для гиперссылок */
        text-decoration: underline; /* Подчеркивание для гиперссылок */
      }
      img {
        max-width: 100%;
        height: auto;
      }
    </style>
  </head>
  <body>
    <h1>The Git Parable – Telegraph</h1>
    <p>Автор: <a href="https://t.me/AXV15" target="_blank">ALEX</a></p>
    <img src="img/image.jpg" alt="Изображение">
    <p>The Git ParableALEXTom Preston-WernerhomeThe Git Parable19 May 2009 - San FranciscoGit is a simple, but extremely powerful system. Most people try to teach Git bydemonstrating a few dozen commands and then yelling “tadaaaaa.” I believe thismethod is flawed. Such a treatment may leave you with the ability to use Git toperform simple tasks, but the Git commands will still feel like magicalincantations. Doing anything out of the ordinary will be terrifying. Until youunderstand the concepts upon which Git is built, you’ll feel like a stranger ina foreign land.The following parable will take you on a journey through the creation of aGit-like system from the ground up. Understanding the concepts presented herewill be the most valuable thing you can do to prepare yourself to harness thefull power of Git. The concepts themselves are quite simple, but allow for anamazing wealth of functionality to spring into existence. Read this parable allthe way through and you should have very little trouble mastering the variousGit commands and wielding the awesome power that Git makes available to you.The ParableImagine that you have a computer that has nothing on it but a text editor and afew file system commands. Now imagine that you have decided to write a largesoftware program on this system. Because you’re a responsible softwaredeveloper, you decide that you need to invent some sort of method for keepingtrack of versions of your software so that you can retrieve code that youpreviously changed or deleted. What follows is a story about how you mightdesign one such version control system (VCS) and the reasoning behind thosedesign choices.SnapshotsAlfred is a friend of yours that works down at the mall as a photographer in oneof those “Special Moments” photo boutiques. All day long he takes photos oflittle kids posing awkwardly in front of jungle or ocean backdrops. During oneof your frequent lunches at the pretzel stand, Alfred tells you a story about awoman named Hazel who brings her daughter in for a portrait every year on thesame day. “She brings the photos from all the past years with her,” Alfred tellsyou. “She likes to remember what her daughter was like at each different stage,as if the snapshots really let her move back and forth in time to those savedmemories.”Like some sort of formulaic plot device, Alfred’s innocent statement acts as acatalyst for you to see the ideal solution to your version control dilemma.Snapshots, like save points in a video game, are really what you care about whenyou need to interact with a VCS. What if you could take snapshots of yourcodebase at any time and resurrect that code on demand? Alfred reads the dawningrealization spreading across your face and knows you’re about to leave himwithout another word to go back and implement whatever genius idea he justcaused you to have. You do not disappoint him.You start your project in a directory named working. As you code,you try to write one feature at a time. When you complete a self-containedportion of a feature, you make sure that all your files are saved and then makea copy of the entire working directory, giving it the namesnapshot-0. After you perform this copy operation, you make sure tonever again change the code files in the new directory. After the next chunk ofwork, you perform another copy, only this time the new directory gets the namesnapshot-1, and so on.To make it easy to remember what changes you made in each snapshot, you add aspecial file named message to each snapshot directory that containsa summary of the work that you did and the date of completion. By printing thecontents of each message, it becomes easy to find a specific change that youmade in the past, in case you need to resurrect some old code.BranchesAfter a bit of time on the project, a candidate for release begins to emerge.Late nights at the keyboard finally yield snapshot-99, the nascentform of what will become Release Version 1.0. It comes to pass that thissnapshot is packaged and distributed to the eagerly awaiting masses. Stoked byexcellent response to your software, you push forward, determined to make thenext version an even bigger success.Your VCS has so far been a faithful companion. Old versions of your code arethere when you need them and can be accessed with ease. But not long after therelease, bug reports start to come in. Nobody’s perfect, you reassure yourself,and snapshot-99 is readily retrievable, glad to be brought back tolife for the purposes of applying bug fixes.Since the release, you’ve created 10 new snapshots. This new work must not beincluded in the 1.0.1 bug fix version you now need to create. To solve this, youcopy snapshot-99 to working so that your workingdirectory is at exactly the point where Version 1.0 was released. A few swiftlines of code and the bug is fixed in the working directory.It is here that a problem becomes apparent. The VCS deals very well with lineardevelopment, but for the first time ever, you need to create a new snapshot thatis not a direct descendent of the preceding snapshot. If you create asnapshot-110 (remember that you created 10 snapshots since therelease), then you’ll be interrupting the linear flow and will have no way ofdetermining the ancestry of any given snapshot. Clearly, you need something morepowerful than a linear system.Studies show that even short exposures to nature can help recharge the mind’screative potential. You’ve been sitting behind the artificially polarized lightof your monitor for days on end. A walk through the woods in the brisk Autumnair will do you some good and with any luck, will help you arrive at an idealsolution to your problem.The great oaks that line the trail have always appealed to you. They seem tostand stark and proud against the perfectly blue sky. Half the ruddy leaves havedeparted from their branches, leaving an intricate pattern of branches in theirwake. Fixating on one of the thousands of branch tips you idly try to follow itback to the solitary trunk. This organically produced structure allows for suchgreat complexity, but the rules for finding your way back to the trunk are sosimple, and perfect for keeping track of multiple lines of development! It turnsout that what they say about nature and creativity are true.By looking at your code history as a tree, solving the problem of ancestrybecomes trivial. All you need to do is include the name of the parent snapshotin the message file you write for each snapshot. Adding just asingle upstream pointer will enable you to easily and accurately trace thehistory of any given snapshot all the way back to the root.Branch NamesYour code history is now a tree. Instead of having a single latest snapshot, youhave two: one for each branch. With a linear system, your sequential numberingsystem let you easily identify the latest snapshot. Now, that ability is lost.Creating new development branches has become so simple that you’ll want to takeadvantage of it all the time. You’ll be creating branches for fixes to oldreleases, for experiments that may not pan out; indeed it becomes possible tocreate a new branch for every feature you begin!But like everything good in life, there is a price to be paid. Each time youcreate a new snapshot, you must remember that the new snapshot becomes thelatest on its branch. Without this information, switching to a new branch wouldbecome a laborious process indeed.Every time you create a new branch you probably give it a name in your head.“This will be the Version 1.0 Maintenance Branch,” you might say. Perhaps yourefer to the former linear branch as the “master” branch.Think about this a little further, though. From the perspective of a tree, whatdoes it mean to name a branch? Naming every snapshot that appears in the historyof a branch would do the trick, but requires the storage of a potentially largeamount of data. Additionally, it still wouldn’t help you efficiently locate thelatest snapshot on a branch.The least amount of information necessary to identify a branch is the locationof the latest snapshot on that branch. If you need to know the list of snapshotsthat are part of the branch you can easily trace the parentage.Storing the branch names is trivial. In a file named branches,stored outside of any specific snapshot, you simply list the name/snapshot pairsthat represent the tips of branches. To switch to a named branch you need onlylook up the snapshot for the corresponding name from this file.Because you’re only storing the latest snapshot on each branch, creating a newsnapshot now contains an additional step. If the new snapshot is being createdas part of a branch, the branches file must be updated so that thename of the branch becomes associated with the new snapshot. A small price topay for the benefit.TagsAfter using branches for a while you notice that they can serve two purposes.First, they can act as movable pointers to snapshots so that you can keep trackof the branch tips. Second, they can be pointed at a single snapshot and nevermove.The first use case allows you to keep track of ongoing development, things like“Release Maintenance”. The second case is useful for labeling points ofinterest, like “Version 1.0” and “Version 1.0.1”.Mixing both of these uses into a single file feels messy. Both types arepointers to snapshots, but one moves and one doesn’t. For the sake of clarityand elegance, you decide to create another file called tags tocontain pointers of the second type.Keeping these two inherently different pointers in separate files will help youfrom accidentally treating a branch as a tag or vice versa.DistributedWorking on your own gets pretty lonely. Wouldn’t it be nice if you could invitea friend to work on your project with you? Well, you’re in luck. Your friend Zoehas a computer setup just like yours and wants to help with the project. Becauseyou’ve created such a great version control system, you tell her all about itand send her a copy of all your snapshots, branches, and tags so she can enjoythe same benefits of the code history.It’s great to have Zoe on the team but she has a habit of taking long trips tofar away places without internet access. As soon as she has the source code, shecatches a flight to Patagonia and you don’t hear from her for a week. In themeantime you both code up a storm. When she finally gets back, you discover acritical flaw in your VCS. Because you’ve both been using the same numberingsystem, you each have directories named ‘snapshot-114’, ‘snapshot-115’, and soon, but with different contents!To make matters worse, you don’t even know who authored the changes in those newsnapshots. Together, you devise a plan for dealing with these problems. First,snapshot messages will henceforth contain author name and email. Second,snapshots will no longer be named with simple numbers. Instead, you’ll use thecontents of the message file to produce a hash. This hash will be guaranteed tobe unique to the snapshot since no two messages will ever have the same date,message, parent, and author. To make sure everything goes smoothly, you bothagree to use the SHA1 hash algorithm that takes the contents of a file andproduces a 40 character hexadecimal string. You both update your histories withthe new technique and instead of clashing ‘snapshot-114’ directories, you nowhave distinct directories named ‘8ba3441b6b89cad23387ee875f2ae55069291f4b’ and‘db9ecb5b5a6294a8733503ab57577db96ff2249e’.With the updated naming scheme, it becomes trivial for you to fetch all the newsnapshots from Zoe’s computer and place them next to your existing snapshots.Because every snapshot specifies its parent, and identical messages (andtherefore identical snapshots) have identical names no matter where they arecreated, the history of the codebase can still be drawn as a tree. Only now, thetree is comprised of snapshots authored by both Zoe and you.This point is important enough to warrant repeating. A snapshot is identified bya SHA1 that uniquely identifies it (and its parent). These snapshots can becreated and moved around between computers without losing their identity orwhere they belong in the history tree of a project. What’s more, snapshots canbe shared or kept private as you see fit. If you have some experimentalsnapshots that you want to keep to yourself, you can do so quite easily. Justdon’t make them available to Zoe!OfflineZoe’s travel habits cause her to spend countless hours on airplanes and boats.Most of the places she visits have no readily available internet access. At theend of the day, she spends more time offline than online.It’s no surprise, then, that Zoe raves about your VCS. All of the day to dayoperations that she needs to do can be done locally. The only time she needs anetwork connection is when she’s ready to share her snapshots with you.MergesBefore Zoe left on her trip, you had asked her to start working off of thebranch named ‘math’ and to implement a function that generated prime numbers.Meanwhile, you were also developing off of the ‘math’ branch, only you werewriting a function to generate magic numbers. Now that Zoe has returned, you arefaced with the task of merging these two separate branches of development into asingle snapshot. Since you both worked on separate tasks, the merge is simple.While constructing the snapshot message for the merge, you realize that thissnapshot is special. Instead of just a single parent, this merge snapshot hastwo parents! The first parent is your latest on the ‘math’ branch and the secondparent is Zoe’s latest on her ‘math’ branch. The merge snapshot doesn’t containany changes beyond those necessary to merge the two disparate parents into asingle codebase.Once you complete the merge, Zoe fetches all the snapshots that you have thatshe does not, which include your development on the ‘math’ branch and your mergesnapshot. Once she does this, both of your histories match exactly!Rewriting HistoryLike many software developers you have a compulsion to keep your code clean andvery well organized. This carries over into a desire to keep your code historywell groomed. Last night you came home after having a few too many pints ofGuinness at the local brewpub and started coding, producing a handful ofsnapshots along the way. This morning, a review of the code you wrote last nightmakes you cringe a little bit. The code is good overall, but you made a lot ofmistakes early on that you corrected in later snapshots.Let’s say the branch on which you did your drunken development is called ‘drunk’and you made three snapshots after you got home from the bar. If the name‘drunk’ points at the latest snapshot on that branch, then you can use a usefulnotation to refer to the parent of that snapshot. The notation ‘drunk^’ meansthe parent of the snapshot pointed to by the branch name ‘drunk’. Similarly‘drunk^^’ means the grandparent of the ‘drunk’ snapshot. So the three snapshotsin chronological order are ‘drunk^^’, ‘drunk^’, and ‘drunk’.You’d really like those three lousy snapshots to be two clean snapshots. Onethat changes an existing function, and one that adds a new file. To accomplishthis revision of history you copy ‘drunk’ to ‘working’ and delete the file thatis new in the series. Now ‘working’ represents the correct modifications to theexisting function. You create a new snapshot from ‘working’ and write themessage to be appropriate to the changes. For the parent you specify the SHA1 ofthe ‘drunk^^^’ snapshot, essentially creating a new branch off of the samesnapshot as last night. Now you can copy ‘drunk’ to ‘working’ and roll asnapshot with the new file addition. As the parent you specify that snapshot youcreated just before this one.As the last step, you change the branch name ‘drunk’ to point to the lastsnapshot you just made.The history of the ‘drunk’ branch now represents a nicer version of what you didlast night. The other snapshots that you’ve replaced are no longer needed so youcan delete them or just leave them around for posterity. No branch names arecurrently pointing at them so it will be hard to find them later on, but if youdon’t delete them, they’ll stick around.Staging AreaAs much as you try to keep your new modifications related to a single feature orlogical chunk, you sometimes get sidetracked and start hacking on somethingtotally unrelated. Only half-way into this do you realize that your workingdirectory now contains what should really be separated as two discretesnapshots.To help you with this annoying situation, the concept of a staging directory isuseful. This area acts as an intermediate step between your working directoryand a final snapshot. Each time you finish a snapshot, you also copy that to astaging directory. Now, every time you finish an edit to a newfile, create a new file, or remove a file, you can decide whether that changeshould be part of your next snapshot. If it belongs, you mimic the change insidestaging. If it doesn’t, you can leave it in workingand make it part of a later snapshot. From now on, snapshots are createddirectly from the staging directory.This separation of coding and preparing the stage makes it easy to specify whatis and is not included in the next snapshot. You no longer have to worry toomuch about making an accidental, unrelated change in your working directory.You have to be a bit careful, though. Consider a file named README.You make an edit to this file and then mimic that in staging. Yougo on about your business, editing other files. After a bit, you make anotherchange to README. Now you have made two changes to that file, butonly one is in the staging area! Were you to create a snapshot now, your secondchange would be absent.The lesson is this: every new edit must be added to the staging area if it is tobe part of the next snapshot.DiffsWith a working directory, a staging area, and loads of snapshots laying around,it starts to get confusing as to what the specific code changes are betweenthese directories. A snapshot message only gives you a summary of what changed,not exactly what lines were changed between two files.Using a diffing algorithm, you can implement a small program that shows you thedifferences in two codebases. As you develop and copy things from your workingdirectory to the staging area, you’ll want to easily see what is differentbetween the two, so that you can determine what else needs to be staged. It’salso important to see how the staging area is different from the last snapshot,since these changes are what will become part of the next snapshot you produce.There are many other diffs you might want to see. The differences between aspecific snapshot and its parent would show you the “changeset” that wasintroduced by that snapshot. The diff between two branches would be helpful formaking sure your development doesn’t wander too far away from the mainline.Eliminating DuplicationAfter a few more trips to Namibia, Istanbul, and Galapagos, Zoe starts tocomplain that her hard drive is filling up with hundreds of nearly identicalcopies of the software. You too have been feeling like all the file duplicationis wasteful. After a bit of thinking, you come up with something very clever.You remember that the SHA1 hash produces a short string that is unique for agiven file contents. Starting with the very first snapshot in the projecthistory, you start a conversion process. First, you create a directory namedobjects outside of the code history. Next, you find the most deeplynested directory in the snapshot. Additionally, you open up a temporary file forwriting. For each file in this directory you perform three steps. Step 1:Calculate the SHA1 of the contents. Step 2: Add an entry into the temp file thatcontains the word ‘blob’ (binary large object), the SHA1 from the first step,and the filename. Step 3: Copy the file to the objects directory and rename itto the SHA1 from step 1. Once finished with all the files, find the SHA1 of thetemp file contents and use that to name the temp file, also placing it in theobjects directory.If at any time the objects directory already contains a file with a given name,then you have already stored that file’s contents and there is no need to do soagain.Now, move up one directory and start over. Only this time, when you get to theentry for the directory that you just processed, enter the word ‘tree’, the SHA1of the temp file from last time, and the directory’s name into the new tempfile. In this fashion you can build up a tree of directory object files thatcontain the SHA1s and names of the files and directory objects that theycontain.Once this has been accomplished for every directory and file in the snapshot,you have a single root directory object file and its corresponding SHA1. Sincenothing contains the root directory, you must record the root tree’s SHA1somewhere. An ideal place to store it is in the snapshot message file. This way,the uniqueness of the SHA1 of the message also depends on the entire contents ofthe snapshot, and you can guarantee with absolute certainty that two identicalsnapshot message SHA1s contain the same files!It’s also convenient to create an object from the snapshot message in the sameway that you do for blobs and trees. Since you’re maintaining a list of branchand tag names that point to message SHA1s you don’t have to worry about losingtrack of which snapshots are important to you.With all of this information stored in the objects directory, you can safelydelete the snapshot directory that you used as the source of this operation. Ifyou want to reconstitute the snapshot at a later date it’s simply a matter offollowing the SHA1 of the root tree stored in the message file and extractingeach tree and blob into their corresponding directory and file.For a single snapshot, this transformation process doesn’t get you much. You’vebasically just converted one filesystem into another and created a lot of workin the process. The real benefits of this system arise from reuse of trees andblobs across snapshots. Imagine two sequential snapshots in which only a singlefile in the root directory has changed. If the snapshots both contain 10directories and 100 files, the transformation process will create 10 trees and100 blobs from the first snapshot but only one new blob and one new tree fromthe second snapshot!By converting every snapshot directory in the old system to object files in thenew system, you can drastically reduce the number of files that are stored ondisk. Now, instead of storing perhaps 50 identical copies of a rarely changedfile, you only need to keep one.Compressing BlobsEliminating blob and tree duplication significantly reduces the total storagesize of your project history, but that’s not the only thing you can do to savespace. Source code is just text. Text can be very efficiently compressed usingsomething like the LZW or DEFLATE compression algorithms. If you compress everyblob before computing its SHA1 and saving it to disk you can reduce the totalstorage size of the project history by another very admirable quantity.The True GitThe VCS you have constructed is now a reasonable facsimile of Git. The maindifference is that Git gives you very nice command lines tools to handle suchthings as creating new snapshots and switching to old ones (Git uses the term“commit” instead of “snapshot”), tracing history, keeping branch tipsup-to-date, fetching changes from other people, merging and diffing branches,and hundreds of other common (and not-so-common tasks).As you continue to learn Git, keep this parable in mind. Git is really verysimple underneath, and it is this simplicity that makes it so flexible andpowerful. One last thing before you run off to learn all the Git commands:remember that it is almost impossible to lose work that has been committed. Evenwhen you delete a branch, all that’s really happened is that the pointer to thatcommit has been removed. All of the snapshots are still in the objectsdirectory, you just need to dig up the commit SHA. In these cases, look upgit reflog. It contains a history of what each branch pointed toand in times of crisis, it will save the day.Here are some resources that you should follow as your next step. Now, go, andbecome a Git master!</p>
    <p>Оригинальная ссылка: <a href="https://telegra.ph/The-Git-Parable-12-13-4" target="_blank">https://telegra.ph/The-Git-Parable-12-13-4</a></p>
  </body>
</html>
